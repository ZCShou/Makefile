# 概述
&emsp;&emsp;什么是 Makefile？或许很多 Windows 的程序员都不知道这个东西，因为那些 Windows 的集成开发环境（integrated development environment，IDE）都为你做了这个工作，但我觉得要作一个好的和专业的程序员，Makefile 还是要懂。这就好像现在有这么多的 HTML 编辑器，但如果你想成为一个专业人士，你还是要了解 HTML 的标签的含义。特别在 Unix 下的软件编译，你就不能不自己写 Makefile 了，会不会写 Makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。

&emsp;&emsp;因为，Makefile 关系到了整个工程的编译规则。一个工程中的源文件不计其数，并且按类型、功能、模块分别放在若干个目录中，Makefile 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 Makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。

&emsp;&emsp;Makefile 带来的好处就是——“自动化编译”，一旦写好，只需要一个 `make` 命令，整个工程完全自动编译，极大的提高了软件开发的效率。 `make` 是一个命令工具，是一个解释 Makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Delphi 的 make，Visual C++ 的 nmake，Linux 下 GNU 的 make。可见，Makefile 都成为了一种在工程方面的编译方法。

&emsp;&emsp;现在讲述如何写 Makefile 的文章比较少，这是我想写这篇文章的原因。当然，不同产商的 `make` 各不相同，也有不同的语法，但其本质都是在 “文件依赖性”上做文章，这里，我仅对 GNU 的 make 进行讲述，我的环境是 RedHat Linux 8.0，`make` 的版本是 3.80。毕竟，这个 make 是应用最为广泛的，也是用得最多的。而且其还是最遵循于 IEEE 1003.2-1992 标准的（POSIX.2）。

&emsp;&emsp;在这篇文档中，将以 C/C++ 的源码作为基础，所以必然涉及一些关于 C/C++ 的编译的知识。关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是 UNIX 下的GCC 和 CC。

## 关于程序的编译和链接
&emsp;&emsp;在此，我想多说关于程序编译的一些规范和方法。一般来说，无论是 C 还是 C++，首先要把源文件编译成中间代码文件，在 Windows 下也就是 .obj 文件，UNIX 下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的 Object File 合成执行文件，这个动作叫作链接（link）。

![编译及链接](./images/compile.gif)

&emsp;&emsp;编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在 C/C++ 文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（ .o 文件或 .obj 文件）。

&emsp;&emsp;链接时，主要是链接函数和全局变量。所以，我们可以使用这些中间目标文件（ .o 文件或 .obj 文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便。所以，我们要给中间目标文件打个包，在Windows 下这种包叫“库文件”（Library File），也就是 .lib 文件，在 UNIX 下，是 Archive File，也就是 .a 文件。

&emsp;&emsp;总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成 Object File。而在链接程序时，链接器会在所有的 Object File 中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在 VC 下，这种错误一般是： Link 2001 错误 ，意思说是说，链接器未能找到函数的实现。你需要指定函数的 Object File。

好，言归正传，GNU 的 `make` 有许多的内容，闲言少叙。